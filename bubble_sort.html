<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Bubble Sort</title>
        <link rel="stylesheet" href="lib/highlight.default.css">
        <link rel="stylesheet" type="text/css" href="css/index.css">
        <link rel="stylesheet" type="text/css" href="css/colorSet1.css">
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
        <script src="lib/highlight.js"></script>
    </head>
    <body>
        <content>
            <header>Bubble Sort</header>
            <a href="index.html"><< Back</a>
            <article>
                <h1>Summary</h1>
                <div class="clear normal">
                    <p>
                        <a target="_blank" href="https://en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a> is one of the simpilest sorting algorithms. 
                        It pops up commonly in interviews, introductory textbooks, and bootcamp tests. It is a comparison sort. A comparison sort is a sort that reads the list by comparing 2 elements at a time.  
                    </p> 

                    <p>
                        <div class="left paddingRight10 one" id="bubble-example"></div>
                        One positive of Bubble Sort is that it can help us understand how a computer thinks. A person is able to look at a problem and come up with a solution on the fly. For example, if given the list [3, 1, 4, 2, 5] a person may look at that and say "Well it's the integers 1 through 5 so I'll just write those in order." However, a computer needs more specific steps than that. Bubble Sort shows one set of steps. These steps have to work across any dataset. For example, the actions above wouldn't work for the list [2, 1, 1, 6, 2]. We want to teach a computer a method to solve either of these problems.
                    </p>

                    <p class="padding">
                        A Bubble Sort is completed by iterating over the elements and comparing each element to the element after it. If the element after it is smaller the elements are swapped. This allows the highest values to Bubble up to the top of the array. In simple implementations a Bubble sort will iterate over an array n - 1 times doing a comparison for n - 1 elements. This means of course that the simple function takes (n - 1) * (n - 1) time or O(n<sup>2</sup>) in all cases.
                    </p>

                    <p>
                        Bubble sort is one of the most controversial sorting algorithms. 
                        It's extremely inefficent, and it has been argued, that
                        it shouldn't be taught in CS courses. This is discussed more fully in <a href='https://users.cs.duke.edu/~ola/bubble/bubble.html'>Bubble Sort: An Archaeological Algorithmic Analysis</a>. 
                    </p>
                </div>
            </article>

            <article>
                <h1>Common Optimizations</h1>
                <div class="normal">
                    <p>
                        There are a couple common optimizations for Bubble Sort.
                    </p>

                    <div id="bubble-optimizations" class="two"></div>

                    <ol>
                        <li>Short Circuit: A short circuit stops the sort once it determines that the array is not in order. This is determined by tracking if it swaped any elements in the last iteration. If it hasn't the array is already in order.</li>
                        <li>Skip: When you run an iteration of Bubble Sort the highest element is moved to the final location. This means that you don't have to check that location again. This optimization will assume that the last element in each iteration is now in the correct position and will skip it in the following round.</li>
                    </ol>

                    <p>
                        Each of these optimizations speeds up the sort. And both can make the sort much more efficent than the simple function, although it can still be extremely inefficent.
                    </p>

                    <p>
                         Coming Soon: graph of function profiling.
                    </p>
                </div>

                <p><a href="sort_comparison.html">Compare Yourself</a></p>
            </article>

            <article>
                <h1>Comparing Efficency Among Orderings</h1>

                <p>The effiency of Bubble Sort varies greatly by the order of the elements to start with when an optimized sort is used. This is because in an ordered list a short circuit can take O(n) while a reversed list will take O(n<sup>2</sup>) as it has to compare every element to every other element.</p>

                <div id="bubble-shuffles" class="two"></div>

                <p>We see that the ordered and almost ordered lists both finish very quickly. While the reversed and randomized lists take much longer. This is an important fact about comparison sorts in general. They tend to work best on mostly sorted lists(with a couple exceptions). This is because if they are able to determine a short circuit on a sorted or almost sorted list they are likely to go through the list few times.</p>

                <p>
                    Coming Soon: graph of function profiling.
                </p>

                <p><a href="sort_comparison.html">Compare Yourself</a></p>
            </article>

            <article>
                <h1>Code</h1>

                <h5>Python</h5>

                <pre><code class="python">
def bubble_sort(nums):
    # Repeat the sort up to n - 1 times
    # if there are 5 elements. It will run the sort 4 times.
    # At minimum this will put 4 of the 5 elements in place.
    # And the array will become sorted.
    for i in range(1, len(nums)):
        # set a variable to check if the array is ordered
        ordered = True
        # For each round look at every number up to the second to last that has not been sorted.
        # We do not need to reconsider the final number of the previous round
        # because bubble sort always puts the highest number in the last position each round.
        for index in range(len(nums) - i):
            # compare each value to the next value in the array.
            # if the next value is smaller swap the values
            value = nums[index]
            next_value = nums[index + 1]
            if next_value < value:
                nums[index], nums[index + 1] = next_value, value
                # if you had to swap change the ordered variable
                ordered = False
        # if the array was ordered break out of the loop
        if ordered:
            break
    # return the sorted array
    return nums
                </code></pre>

                <p><a href="https://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort">Other Languages</a></p>
            </article>

            <article>
                <h1>Further Optimization</h1>

                <p>
                    As I stated before Bubble Sort is an exceptionally poor sorting algorithm. It is not at all optimized and is problematic at best. But the simplicity of the algorithm does give some freedom to test optimizations on it. This may allow us to think about things that could improve the sort and may event help us to understand how alternative sorts might be derived from thinking about Bubble Sort.
                </p>

                <h2>Concurrency</h2>

                <p>
                    One simple way to optimize is to process things concurrently.
                </p>

                <div id="bubble-concur" class="two"></div>

                <p>
                    It becomes very obvious upon observation that the concurrent sorts are much fast in time. They do not, however, change the actual number of swaps or comparisons that need to be made. Instead they use additional resources to complete faster by doing things at the same time. The last sort show here is an Odd-Even Sort. This is technically not a Bubble Sort but is a clear extension of this concurrency idea. 
                </p>

                <p>
                    Coming Soon: graph of function profiling.
                </p>

                <h2>Considering Algorithmic Issues</h2>

                <p>
                    One thing that developers do is look for fixable problems in algorithms. Looking at Bubble Sort something jumps out at me. If I need to move a number back 4 places I have to iterate 4 times to do that. This seems inefficent. Would it be faster if I didn't have to do that? 
                </p>

                <div id="bubble-dont-restart" class="two"></div>

                <p>
                    Here we see a test of that function against other functions, and it doesn't seem to be much better than the original Bubble Sort. however, by watching the visualization we can see why. It's still making a lot of comparisons. It moves large sets of unordered data around. Then when it finally orders it, it still looks at it all again as it moves up. So we can assume that we can optimize it further. Examples of this are shown in the second 2 examples. Gnome sort creates a "sorted list" as a sub list of the full list and moves each element into that list. Cocktail sort sorts both upwards and downwards to move elements faster(although this implementation does not include a short circuit, but it could).
                </p>

                <p>We can start to see from these examples how we move from a simple sort like Bubble to increasingly more complex sorts to optimize different aspects of a sort.</p>

                <p>
                    Coming Soon: graph of function profiling.
                </p>

                <p><a href="sort_comparison.html">Compare Yourself</a></p>
            </article>

        

        <script>hljs.initHighlightingOnLoad();</script>
        <script src="dist/utils.entry.js"></script>
        <script src="dist/queens.entry.js"></script>
        <script src="dist/bubble.entry.js"></script>
        </content>
    </body>
</html>
